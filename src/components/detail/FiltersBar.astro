---
/**
 * Filters Bar Component
 * Allows filtering and sorting of questions by category, classification, and various metrics
 * Styled to align with the Dark Doppler aesthetic
 */

import categoriesConfig from '../../config/categories.json';

interface Props {
  categories: string[];
}

const { categories } = Astro.props;
---

<div class="surface sticky top-20 z-40 border border-slate-800/70 shadow-xl">
  <div class="flex flex-col lg:flex-row gap-4 items-start lg:items-center justify-between">
    <!-- Left Side: Filters -->
    <div class="flex flex-col sm:flex-row gap-3 flex-1 w-full">
      <div class="flex-1 min-w-[200px]">
        <label for="category-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Category
        </label>
        <select
          id="category-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Categories</option>
          {categoriesConfig.categories.map(cat => (
            <option value={cat.id}>{cat.name}</option>
          ))}
        </select>
      </div>

      <div class="flex-1 min-w-[200px]">
        <label for="classification-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Classification
        </label>
        <select
          id="classification-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Classifications</option>
          <option value="FULL_DISCLOSURE">Full Disclosure</option>
          <option value="PARTIAL">Partial</option>
          <option value="UNCLEAR">Unclear</option>
          <option value="NO_DISCLOSURE">No Disclosure</option>
        </select>
      </div>

      <div class="flex-1 min-w-[200px]">
        <label for="quality-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Quality Grade
        </label>
        <select
          id="quality-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Grades</option>
          <option value="A">A (90-100%)</option>
          <option value="B">B (80-89%)</option>
          <option value="C">C (70-79%)</option>
          <option value="D">D (60-69%)</option>
          <option value="F">F (&lt;60%)</option>
        </select>
      </div>
    </div>

    <!-- Right Side: Sort and Actions -->
    <div class="flex gap-3 items-end">
      <div class="min-w-[180px]">
        <label for="sort-select" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Sort By
        </label>
        <select
          id="sort-select"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="quality-desc">Quality (High to Low)</option>
          <option value="quality-asc">Quality (Low to High)</option>
          <option value="question-id">Question ID</option>
          <option value="evidence-desc">Evidence Count (High to Low)</option>
          <option value="evidence-asc">Evidence Count (Low to High)</option>
        </select>
      </div>

      <button
        id="reset-filters"
        class="px-4 py-2 text-sm font-medium text-slate-200 bg-slate-800/70 hover:bg-slate-700/80 rounded-lg transition-colors border border-slate-700"
        title="Reset all filters"
      >
        Reset
      </button>

      <button
        id="toggle-all"
        class="px-4 py-2 text-sm font-medium text-sky-200 bg-sky-600/20 hover:bg-sky-500/30 rounded-lg transition-colors border border-sky-500/40"
        title="Expand or collapse all questions"
      >
        Expand All
      </button>
    </div>
  </div>

  <div id="active-filters" class="mt-3 flex flex-wrap gap-2 hidden">
    <span class="text-xs font-semibold text-slate-300 uppercase tracking-wide">Active Filters:</span>
  </div>

  <div id="results-count" class="mt-3 text-xs text-slate-400"></div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
    const classificationFilter = document.getElementById('classification-filter') as HTMLSelectElement;
    const qualityFilter = document.getElementById('quality-filter') as HTMLSelectElement;
    const sortSelect = document.getElementById('sort-select') as HTMLSelectElement;

    const resetButton = document.getElementById('reset-filters') as HTMLButtonElement;
    const toggleAllButton = document.getElementById('toggle-all') as HTMLButtonElement;

    const activeFiltersDiv = document.getElementById('active-filters') as HTMLDivElement;
    const resultsCountDiv = document.getElementById('results-count') as HTMLDivElement;
    const questionsContainer = document.getElementById('questions-container') as HTMLElement | null;

    const questionNodes = Array.from(document.querySelectorAll('[data-question-id]'));
    const totalQuestionCount = questionsContainer
      ? parseInt(questionsContainer.dataset.totalQuestions || String(questionNodes.length), 10)
      : questionNodes.length;

    let allExpanded = false;

    function applyFiltersAndSort() {
      const categoryValue = categoryFilter.value;
      const classificationValue = classificationFilter.value;
      const qualityValue = qualityFilter.value;
      const sortValue = sortSelect.value;

      let visibleCount = 0;

      questionNodes.forEach(question => {
        const questionEl = question as HTMLElement;
        const category = questionEl.dataset.category || '';
        const classification = questionEl.dataset.classification || '';
        const grade = questionEl.dataset.grade || '';

        let visible = true;

        if (categoryValue !== 'all' && !category.includes(categoryValue)) {
          visible = false;
        }

        if (classificationValue !== 'all' && classification !== classificationValue) {
          visible = false;
        }

        if (qualityValue !== 'all' && grade !== qualityValue) {
          visible = false;
        }

        questionEl.style.display = visible ? '' : 'none';
        if (visible) visibleCount++;
      });

      const container = questionsContainer;
      if (container) {
        const visibleQuestions = questionNodes.filter(q => (q as HTMLElement).style.display !== 'none');

        visibleQuestions.sort((a, b) => {
          const aEl = a as HTMLElement;
          const bEl = b as HTMLElement;

          switch (sortValue) {
            case 'quality-desc':
              return parseFloat(bEl.dataset.score || '0') - parseFloat(aEl.dataset.score || '0');
            case 'quality-asc':
              return parseFloat(aEl.dataset.score || '0') - parseFloat(bEl.dataset.score || '0');
            case 'evidence-desc':
              return parseInt(bEl.dataset.snippets || '0') - parseInt(aEl.dataset.snippets || '0');
            case 'evidence-asc':
              return parseInt(aEl.dataset.snippets || '0') - parseInt(bEl.dataset.snippets || '0');
            case 'question-id':
            default:
              return (aEl.dataset.questionId || '').localeCompare(bEl.dataset.questionId || '');
          }
        });

        visibleQuestions.forEach(q => container.appendChild(q));
      }

      if (resultsCountDiv) {
        resultsCountDiv.textContent = `Showing ${visibleCount} of ${totalQuestionCount} questions`;
      }

      updateActiveFilters();
    }

    function updateActiveFilters() {
      if (!activeFiltersDiv) return;

      const activeFilters: string[] = [];

      if (categoryFilter.value !== 'all') {
        activeFilters.push(`Category: ${categoryFilter.options[categoryFilter.selectedIndex].text}`);
      }
      if (classificationFilter.value !== 'all') {
        activeFilters.push(`Classification: ${classificationFilter.options[classificationFilter.selectedIndex].text}`);
      }
      if (qualityFilter.value !== 'all') {
        activeFilters.push(`Grade: ${qualityFilter.value}`);
      }

      if (activeFilters.length > 0) {
        activeFiltersDiv.classList.remove('hidden');
        const tagsHTML = activeFilters.map(filter =>
          `<span class="px-2 py-1 text-xs bg-sky-500/20 text-sky-200 rounded border border-sky-400/30">${filter}</span>`
        ).join('');
        activeFiltersDiv.innerHTML = '<span class="text-xs font-semibold text-slate-300 uppercase tracking-wide">Active Filters:</span>' + tagsHTML;
      } else {
        activeFiltersDiv.classList.add('hidden');
        activeFiltersDiv.innerHTML = '';
      }
    }

    function resetFilters() {
      categoryFilter.value = 'all';
      classificationFilter.value = 'all';
      qualityFilter.value = 'all';
      sortSelect.value = 'quality-desc';
      applyFiltersAndSort();
    }

    function toggleAll() {
      allExpanded = !allExpanded;
      questionNodes.forEach(question => {
        const questionEl = question as HTMLElement;
        const content = questionEl.querySelector('.question-content') as HTMLElement | null;
        const toggle = questionEl.querySelector('.toggle-icon') as HTMLElement | null;

        if (content && toggle) {
          if (allExpanded) {
            content.style.display = 'block';
            content.classList.remove('hidden');
            toggle.textContent = '▾';
            toggle.classList.add('text-sky-300');
            toggle.classList.remove('text-slate-500');
            questionEl.classList.add('expanded');
          } else {
            content.style.display = 'none';
            content.classList.add('hidden');
            toggle.textContent = '▸';
            toggle.classList.remove('text-sky-300');
            toggle.classList.add('text-slate-500');
            questionEl.classList.remove('expanded');
          }
        }
      });

      toggleAllButton.textContent = allExpanded ? 'Collapse All' : 'Expand All';
    }

    categoryFilter.addEventListener('change', applyFiltersAndSort);
    classificationFilter.addEventListener('change', applyFiltersAndSort);
    qualityFilter.addEventListener('change', applyFiltersAndSort);
    sortSelect.addEventListener('change', applyFiltersAndSort);
    resetButton.addEventListener('click', resetFilters);
    toggleAllButton.addEventListener('click', toggleAll);

    applyFiltersAndSort();
  });
</script>
