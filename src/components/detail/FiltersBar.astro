---
/**
 * Filters Bar Component
 * Allows filtering and sorting of questions by category, classification, and various metrics
 * Styled to align with the Dark Doppler aesthetic
 */

import categoriesConfig from '../../config/categories.json';

interface Props {
  categories: string[];
}

const { categories } = Astro.props;
---

<div class="surface sticky top-20 z-40 border border-slate-800/70 shadow-xl p-5">
  <div class="flex flex-col gap-4 w-full">
    <!-- Row 1 -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
      <div class="flex-1 min-w-[200px]">
        <label for="category-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Category
        </label>
        <select
          id="category-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Categories</option>
          {categoriesConfig.categories.map(cat => (
            <option value={cat.id}>{cat.name}</option>
          ))}
        </select>
      </div>

      <div class="flex-1 min-w-[200px]">
        <label for="timeframe-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Disclosure Timeframe
          <span
            class="text-[12px] text-slate-400"
            title="Backward-looking: Completed past events. Present day: Ongoing as of reporting date. Forward-looking: Anticipated future risks not yet manifested. Multiple/Unclear: Ambiguous timeframe."
            aria-label="Backward-looking: Completed past events. Present day: Ongoing as of reporting date. Forward-looking: Anticipated future risks not yet manifested. Multiple/Unclear: Ambiguous timeframe."
          >
            ⓘ
          </span>
        </label>
        <select
          id="timeframe-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Timeframes</option>
          <option value="present day">Present day</option>
          <option value="forward-looking">Forward-looking</option>
          <option value="backward-looking">Backward-looking</option>
          <option value="multiple or unclear">Multiple or Unclear</option>
        </select>
      </div>

      <div class="flex-1 min-w-[200px]">
        <label for="framing-filter" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
          Narrative Framing
          <span
            class="text-[12px] text-slate-400"
            title="Risk: Harm, uncertainty, or negative consequences. Opportunity: Beneficial or value-creating. Neutral: Factual content without evaluative framing. Both: Discusses risks and opportunities together."
            aria-label="Risk: Harm, uncertainty, or negative consequences. Opportunity: Beneficial or value-creating. Neutral: Factual content without evaluative framing. Both: Discusses risks and opportunities together."
          >
            ⓘ
          </span>
        </label>
        <select
          id="framing-filter"
          class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
        >
          <option value="all">All Framings</option>
          <option value="balanced">Balanced</option>
          <option value="opportunity">Opportunity</option>
          <option value="risk">Risk</option>
          <option value="neutral">Neutral</option>
        </select>
      </div>
    </div>

    <!-- Row 2 -->
    <div class="min-w-[260px]">
      <label for="question-jump-text-full" class="block text-xs font-semibold text-slate-300 mb-1 uppercase tracking-wide">
        Jump to Question
      </label>
      <select
        id="question-jump-text-full"
        class="w-full bg-slate-900/70 border border-slate-700 rounded-lg px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:border-transparent"
      >
        <option value="">Show all questions</option>
      </select>
    </div>

    <!-- Row 3 -->
    <div class="flex gap-3">
      <button
        id="reset-filters"
        class="px-4 py-2 text-sm font-medium text-slate-200 bg-slate-800/70 hover:bg-slate-700/80 rounded-lg transition-colors border border-slate-700"
        title="Reset all filters"
      >
        Reset
      </button>

      <button
        id="toggle-all"
        class="px-4 py-2 text-sm font-medium text-sky-200 bg-sky-600/20 hover:bg-sky-500/30 rounded-lg transition-colors border border-sky-500/40"
        title="Expand or collapse all questions"
      >
        Expand All
      </button>
    </div>
  </div>

  <div id="active-filters" class="mt-3 flex flex-wrap gap-2 hidden">
    <span class="text-xs font-semibold text-slate-300 uppercase tracking-wide">Active Filters:</span>
  </div>

  <div id="results-count" class="mt-3 text-xs text-slate-400"></div>
</div>

<script>
  const collapsedIcon = '▸';
  const expandedIcon = '▾';

  function initFiltersBar() {
    const container = document.getElementById('questions-container');
    if (!(container instanceof HTMLElement)) {
      return;
    }

    const categoryFilter = document.getElementById('category-filter');
  const timeframeFilter = document.getElementById('timeframe-filter');
  const framingFilter = document.getElementById('framing-filter');
    const questionJumpTextFullSelect = document.getElementById('question-jump-text-full');
  const resetButton = document.getElementById('reset-filters');
  const toggleAllButton = document.getElementById('toggle-all');
  const activeFiltersDiv = document.getElementById('active-filters');
  const resultsCountDiv = document.getElementById('results-count');

    if (!(categoryFilter instanceof HTMLSelectElement) ||
        !(timeframeFilter instanceof HTMLSelectElement) ||
        !(framingFilter instanceof HTMLSelectElement) ||
        !(questionJumpTextFullSelect instanceof HTMLSelectElement) ||
        !(resetButton instanceof HTMLButtonElement) ||
        !(toggleAllButton instanceof HTMLButtonElement)) {
      return;
    }

    const questionNodes = Array.from(container.querySelectorAll('.question-card')).filter(
      (node) => node instanceof HTMLElement
    );

    // Parse all questions map from data attribute
    let allQuestionsMap = new Map();
    const allQuestionsData = container.getAttribute('data-all-questions');
    if (allQuestionsData) {
      try {
        const parsed = JSON.parse(allQuestionsData);
        allQuestionsMap = new Map(Object.entries(parsed));
      } catch (e) {
        console.error('Failed to parse all questions data:', e);
      }
    }

    let allExpanded = false;
    let selectedQuestionId = '';
    let selectedQuestionText = '';
    const totalQuestionCount = questionNodes.length;

    function setQuestionExpanded(card, expand) {
      if (!(card instanceof HTMLElement)) {
        return;
      }

      const content = card.querySelector('.question-content');
      const toggle = card.querySelector('.toggle-icon');
      const header = card.querySelector('.question-header');

      if (!(content instanceof HTMLElement) || !(toggle instanceof HTMLElement) || !(header instanceof HTMLElement)) {
        return;
      }

      if (expand) {
        content.hidden = false;
        content.classList.remove('hidden');
        content.removeAttribute('hidden');
        toggle.textContent = expandedIcon;
        toggle.classList.add('text-sky-300');
        toggle.classList.remove('text-slate-500');
        header.setAttribute('aria-expanded', 'true');
        card.classList.add('expanded');
      } else {
        content.hidden = true;
        content.classList.add('hidden');
        content.setAttribute('hidden', '');
        toggle.textContent = collapsedIcon;
        toggle.classList.remove('text-sky-300');
        toggle.classList.add('text-slate-500');
        header.setAttribute('aria-expanded', 'false');
        card.classList.remove('expanded');
      }
    }

    const financialOrder = ['financial', 'partial-type', 'non-financial', 'none'];
    const timeframeOrder = ['present day', 'forward-looking', 'backward-looking', 'multiple or unclear', 'none'];
    const framingOrder = ['balanced', 'opportunity', 'risk', 'neutral', 'none'];

    function compareByOrder(valueA, valueB, order) {
      const a = (valueA || 'none').toLowerCase();
      const b = (valueB || 'none').toLowerCase();
      const indexA = order.indexOf(a);
      const indexB = order.indexOf(b);
      const safeIndexA = indexA === -1 ? order.length : indexA;
      const safeIndexB = indexB === -1 ? order.length : indexB;

      if (safeIndexA !== safeIndexB) {
        return safeIndexA - safeIndexB;
      }

      return a.localeCompare(b);
    }

    function getComparator(sortValue) {
      switch (sortValue) {
        case 'evidence-asc':
          return (a, b) => (parseInt(a.dataset.snippets || '0', 10) || 0) - (parseInt(b.dataset.snippets || '0', 10) || 0);
        case 'evidence-desc':
          return (a, b) => (parseInt(b.dataset.snippets || '0', 10) || 0) - (parseInt(a.dataset.snippets || '0', 10) || 0);
        case 'question-id':
          return (a, b) => (a.dataset.questionId || '').localeCompare(b.dataset.questionId || '');
        case 'financial-type':
          return (a, b) => compareByOrder(a.dataset.primaryFinancial, b.dataset.primaryFinancial, financialOrder);
        case 'timeframe':
          return (a, b) => compareByOrder(a.dataset.primaryTimeframe, b.dataset.primaryTimeframe, timeframeOrder);
        case 'framing':
          return (a, b) => compareByOrder(a.dataset.primaryFraming, b.dataset.primaryFraming, framingOrder);
        default:
          return (a, b) => (a.dataset.questionId || '').localeCompare(b.dataset.questionId || '');
      }
    }

    function updateActiveFilters() {
      if (!(activeFiltersDiv instanceof HTMLElement)) {
        return;
      }

      const activeFilters = [];

      if (selectedQuestionId) {
        const displayText = selectedQuestionText || selectedQuestionId;
        activeFilters.push(`Question: ${displayText}`);
      }
      if (categoryFilter.value !== 'all') {
        activeFilters.push(`Category: ${categoryFilter.options[categoryFilter.selectedIndex].text}`);
      }
      if (timeframeFilter.value !== 'all') {
        activeFilters.push(`Timeframe: ${timeframeFilter.options[timeframeFilter.selectedIndex].text}`);
      }
      if (framingFilter.value !== 'all') {
        activeFilters.push(`Framing: ${framingFilter.options[framingFilter.selectedIndex].text}`);
      }

      if (activeFilters.length > 0) {
        activeFiltersDiv.classList.remove('hidden');
        const tagsHTML = activeFilters
          .map(filter => `<span class="px-2 py-1 text-xs bg-sky-500/20 text-sky-200 rounded border border-sky-400/30">${filter}</span>`)
          .join('');
        activeFiltersDiv.innerHTML =
          '<span class="text-xs font-semibold text-slate-300 uppercase tracking-wide">Active Filters:</span>' + tagsHTML;
      } else {
        activeFiltersDiv.classList.add('hidden');
        activeFiltersDiv.innerHTML = '';
      }
    }

    function applyFiltersAndSort() {
      const categoryValue = categoryFilter.value;
      const timeframeValue = timeframeFilter.value;
      const framingValue = framingFilter.value;

      let visibleCount = 0;

      questionNodes.forEach(questionEl => {
        const matchesSelected = !selectedQuestionId ||
          (questionEl.dataset.questionId || '').toLowerCase() === selectedQuestionId.toLowerCase();
        const matchesCategory = categoryValue === 'all' || questionEl.dataset.categoryId === categoryValue;

        const questionTimeframes = (questionEl.dataset.timeframes || '')
          .split('|')
          .map(value => value.trim().toLowerCase())
          .filter(Boolean);
        const questionFramings = (questionEl.dataset.framings || '')
          .split('|')
          .map(value => value.trim().toLowerCase())
          .filter(Boolean);

        const matchesTimeframe = timeframeValue === 'all' || questionTimeframes.includes(timeframeValue);
        const matchesFraming = framingValue === 'all' || questionFramings.includes(framingValue);

        const visible = selectedQuestionId
          ? matchesSelected
          : matchesCategory && matchesTimeframe && matchesFraming;

        if (visible) {
          questionEl.style.display = '';
          visibleCount += 1;
        } else {
          questionEl.style.display = 'none';
        }
      });

      if (resultsCountDiv instanceof HTMLElement) {
        resultsCountDiv.textContent = `Showing ${visibleCount} of ${totalQuestionCount} questions`;
      }

      updateActiveFilters();

      allExpanded = questionNodes.every(card => {
        if (card.style.display === 'none' || card.dataset.expandable !== 'true') {
          return true;
        }
        return card.classList.contains('expanded');
      });

      toggleAllButton.textContent = allExpanded ? 'Collapse All' : 'Expand All';
    }

    function resetFilters() {
      categoryFilter.value = 'all';
      timeframeFilter.value = 'all';
      framingFilter.value = 'all';
      questionJumpTextFullSelect.value = '';
      selectedQuestionId = '';
      selectedQuestionText = '';
      applyFiltersAndSort();
    }

    function buildQuestionJumpOptions() {
      const ids = Array.from(new Set(
        questionNodes
          .map(node => node.dataset.questionId || '')
          .filter(Boolean)
      )).sort((a, b) => a.localeCompare(b));

      const texts = questionNodes
        .map(node => ({
          id: node.dataset.questionId || '',
          text: node.dataset.questionText || ''
        }))
        .filter(item => item.id);

      // Deduplicate by id to avoid repeats when same question text appears multiple times
      const seen = new Set<string>();
      questionJumpTextFullSelect.innerHTML = '<option value=\"\">Show all questions</option>';
      texts.forEach(item => {
        if (seen.has(item.id)) return;
        seen.add(item.id);
        const option = document.createElement('option');
        option.value = item.id;
        option.textContent = item.text || item.id;
        option.title = item.text || item.id;
        questionJumpTextFullSelect.appendChild(option);
      });
    }

    function jumpToQuestion(questionId, preserveText = false) {
      selectedQuestionId = questionId;

      // Get the question text from the dropdown only if not already set
      if (!preserveText) {
        if (questionId && questionJumpTextFullSelect instanceof HTMLSelectElement) {
          const selectedOption = questionJumpTextFullSelect.options[questionJumpTextFullSelect.selectedIndex];
          selectedQuestionText = selectedOption ? selectedOption.textContent || '' : '';
        } else {
          selectedQuestionText = '';
        }
      }

      applyFiltersAndSort();

      if (!questionId) {
        return;
      }

      const targetCard = questionNodes.find(
        node => (node.dataset.questionId || '').toLowerCase() === questionId.toLowerCase()
      );

      if (!targetCard) {
        // Question exists in URL but not on page (likely has 0 disclosures)
        // Use the selectedQuestionText which was set from URL or map
        const questionText = selectedQuestionText || allQuestionsMap.get(questionId) || `Question ${questionId}`;
        if (resultsCountDiv instanceof HTMLElement) {
          resultsCountDiv.innerHTML = `<span class="text-base font-semibold">No disclosures found for: ${questionText}</span>`;
          resultsCountDiv.classList.add('text-amber-400');
        }
        // Clear the filter after showing the message
        window.setTimeout(() => {
          selectedQuestionId = '';
          selectedQuestionText = '';
          if (questionJumpTextFullSelect instanceof HTMLSelectElement) {
            questionJumpTextFullSelect.value = '';
          }
          applyFiltersAndSort();
          if (resultsCountDiv instanceof HTMLElement) {
            resultsCountDiv.classList.remove('text-amber-400');
          }
        }, 4000);
        return;
      }

      setQuestionExpanded(targetCard, true);
      targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

      targetCard.classList.add('ring', 'ring-sky-400');
      window.setTimeout(() => {
        targetCard.classList.remove('ring', 'ring-sky-400');
      }, 1200);
    }

    function toggleAll() {
      allExpanded = !allExpanded;

      questionNodes.forEach(questionEl => {
        if (questionEl.style.display === 'none' || questionEl.dataset.expandable !== 'true') {
          return;
        }

        setQuestionExpanded(questionEl, allExpanded);
      });

      toggleAllButton.textContent = allExpanded ? 'Collapse All' : 'Expand All';
    }

    container.addEventListener('click', event => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }

      const header = target.closest('.question-header');
      if (!(header instanceof HTMLElement)) {
        return;
      }

      const card = header.closest('.question-card');
      if (!(card instanceof HTMLElement) || card.dataset.expandable !== 'true') {
        return;
      }

      if (target.closest('button')) {
        return;
      }

      const content = card.querySelector('.question-content');
      if (!(content instanceof HTMLElement)) {
        return;
      }

      const shouldExpand = content.classList.contains('hidden') || content.hasAttribute('hidden');
      setQuestionExpanded(card, shouldExpand);

      if (shouldExpand) {
        allExpanded = questionNodes.every(node => {
          if (node.style.display === 'none' || node.dataset.expandable !== 'true') {
            return true;
          }
          return node.classList.contains('expanded');
        });
      } else {
        allExpanded = false;
      }

      toggleAllButton.textContent = allExpanded ? 'Collapse All' : 'Expand All';
    });

    categoryFilter.addEventListener('change', applyFiltersAndSort);
    timeframeFilter.addEventListener('change', applyFiltersAndSort);
    framingFilter.addEventListener('change', applyFiltersAndSort);
      questionJumpTextFullSelect.addEventListener('change', () => {
        const val = questionJumpTextFullSelect.value;
        jumpToQuestion(val);
      });
    resetButton.addEventListener('click', resetFilters);
    toggleAllButton.addEventListener('click', toggleAll);

    buildQuestionJumpOptions();
    applyFiltersAndSort();

    // Check for URL hash and auto-expand the question
    if (window.location.hash) {
      const hash = window.location.hash.slice(1); // Remove the '#'
      if (hash.startsWith('question-')) {
        // Parse question ID and optional question text from hash
        const hashParts = hash.split('&');
        const questionPart = hashParts[0];
        const questionId = questionPart.replace('question-', '');
        
        // Look for qtext parameter
        let questionTextFromUrl = '';
        hashParts.forEach(part => {
          if (part.startsWith('qtext=')) {
            questionTextFromUrl = decodeURIComponent(part.substring(6));
          }
        });
        
        // Small delay to ensure DOM is ready
        window.setTimeout(() => {
          // Set the dropdown value to the question ID
          if (questionJumpTextFullSelect instanceof HTMLSelectElement) {
            questionJumpTextFullSelect.value = questionId;
          }
          
          // Set selectedQuestionText BEFORE calling jumpToQuestion
          // Priority: URL parameter > dropdown > map
          if (questionTextFromUrl) {
            selectedQuestionText = questionTextFromUrl;
          } else if (questionJumpTextFullSelect instanceof HTMLSelectElement) {
            const selectedOption = questionJumpTextFullSelect.options[questionJumpTextFullSelect.selectedIndex];
            selectedQuestionText = selectedOption ? selectedOption.textContent || '' : '';
          }
          
          // If we still don't have text, use the map
          if (!selectedQuestionText) {
            selectedQuestionText = allQuestionsMap.get(questionId) || '';
          }
          
          jumpToQuestion(questionId, true);
        }, 100);
      }
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFiltersBar);
  } else {
    initFiltersBar();
  }

  document.addEventListener('astro:page-load', initFiltersBar);
</script>

